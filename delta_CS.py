# -*- coding: utf-8 -*-
"""
Created on Tue Jul 16 13:24:11 2019

@author: dioni
"""
"""
CS_delta: comparison of experimental chemical shift data with predictions from
PPM and ch3shift. 
    Copyright (C) 2019 Dionisio Sanchez Cabrera (dionisio.sanchez.cab@gmail.com)

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
"""
import numpy as np
import sys
import re
import pandas as pd
import os 
import math
import re
import Bio
from Bio import *
from Bio import pairwise2
from Bio import SeqUtils
import biopandas
from biopandas.pdb import *
import argparse
import pynmrstar

###############################################################################
###############              PARSING ARGUMENTS              ###################
###############################################################################
#### parsing argument
parser = argparse.ArgumentParser(description='Comparison of chemical shifts with experiments.')
parser.add_argument('-exp','--experimental',type=str, help='BMRB entry number of the entity OR name of the BMRB file.')
parser.add_argument('-bp','--bmrb_pre',type=str, help='Name of the bmrb-like file generated by ppmone.')
parser.add_argument('-ch3shift','--ch3_shift',type=str, help='Name of the output generated by ch3shift.')
parser.add_argument('-ref','--reference',type=str, help='Name of the pdb-file used as reference')
parser.add_argument('-pdb_nom','--pdb_nom',type=int, help='Version of the PDB nomenclature'
                    'used in your reference structure. Check the nomenclature.txt file and choose 2 if it is using the one under PDBV2 or 3 for the one under PDBV3. You can modify single entries to correct for discrepancies')

args=parser.parse_args()
parser.print_help()

###############################################################################
###############              FUNCTIONS DEFINITION              ################
###############################################################################

def process_bmrb(filename,name):
    try:
        file_pr=open(str(name),'w')
        file=open(filename,'r')
    except FileNotFoundError as err: 
        print('There is no ppm output file under that name')


    lines=file.readlines()
    start=0
    for line in lines: 
        if start==True:
            if re.match(r'\s+[0-9]+\s+[0-9]+.+',line):
                file_pr.write(line)
        elif re.match(r'\s+_Chem_shift_ambiguity_code\s*',line):
            start=True
    file_pr.close()
    
    
    
def extract_sequence(index):
    '''This function extracts the residue sequence from the a pandas dataframe where having 
    the columns 'resID' and 'residue'. '''
    col1=index.columns[0]
    col2=index.columns[1]
    
    resID_pre=index.iloc[0][col1]
    residue_pre=index.iloc[1][col2]
    
    list_residues_df=[residue_pre]
    
    for i, row in index.iterrows():
         if row[col1]!=resID_pre:
             list_residues_df.append(row[col2])
             resID_pre=row[col1]
    return Bio.SeqUtils.seq1(''.join(list_residues_df))


                
def renumber_sequentially(index,col1,col2):
    '''This function takes a pandas dataframe / index object and renumbers its (numerical)
    feature 'col' sequentially. E.g. for a sequence with gaps in the numbering it will create a new column 'id_seq' 
    with a sequential numbering starting at 0. This avoids troubles when to chains
    are present'''
    #obtain first residue and first residues id 
    resID_pre=index.iloc[0][col1]
    residue_pre=index.iloc[1][col2]
    
    
    list_ids=[] #list of the new values of col1 (i.e.=new residues_id)
    
    #Counter used to change residues upon iteration
    counter=0
    
    #List of the residues. Used to obtain the sequence. Second object returned by 
    #the function
    list_residues=[residue_pre]
    idx=0 #the new resID will start at 0
    for i, row in index.iterrows():
         if row[col1]!=resID_pre:
             list_ids=list_ids + counter*[idx]
             counter=1
             idx+=1
             list_residues.append(row[col2])
             resID_pre=row[col1]

         else:
             counter+=1
    list_ids=list_ids + counter*[idx]
    
    index.at[:,'id_seq']=list_ids

    return index



def experimental_df(entry):
    '''Takes a bmrb entry number or a NMR-star file and creates a pandas DataFrame'''

    if os.path.isfile(entry):
        print("You are submitting a .txt data file with experimental chemical shift entries")
        try:
            entryExp=pynmrstar.Entry.from_file(entry)
        except FileNotFoundError as err: #Hd
            print('The entry file you submitted is not valid.\n',err)
            sys.exit('The entry file you submitted is not a valid one. Please, check it that you are submitting the right file.')

    elif re.match('[0-9]+',entry):
        entry=int(entry)
        print("You are trying to retrieve the chemical shift dataset deposited in the BMRB data base under the number {}.".format(entry))
        try:
            entryExp= pynmrstar.Entry.from_database(entry)
        except OSError as err:
            print('The entry number you submitted is not right. ',err)
            sys.exit('There is no data set under the number alias you have provided. Check for mistakes and try again.')

    else: 
        raise Exception('You must provide a file path or a bmrb entry code')
        sys.exit('Provide a right input in the form of bmbr entry number or NMR-star file')

    #defines a list with all the atoms in the structure
    cs_results_sets=[]
    cs_results_sets_list=[]
    
    #iterates over all the atoms in Entryexp
    for chemical_shift_loop in entryExp.get_loops_by_category("Atom_chem_shift"):
        cs_results_sets.append(chemical_shift_loop.get_tag(['Comp_index_ID','Comp_ID','Atom_ID','Atom_type','Val','Val_err']))
        
    #for nmrstar entries of polymers. EntryExp will be a list with the 
    # structure [[part1],[part2]...] where each part is a list with all the atoms. 
    # This transforms the "list of lists" structure into a single list. 
    for m in range(len(cs_results_sets)):  
        for i in range(len(cs_results_sets[m])):
            line=cs_results_sets[m][i]
            cs_results_sets[m][i]=[float(j) if re.match(r'\d+\.*\d*',j) else j for j in line]
            cs_results_sets_list.append(line)
    
    #creates a dataframe and corrects datatypes. 
    df=pd.DataFrame(cs_results_sets_list,columns=['resID_old','residue','atomtype','element','CS_exp','error_exp']) 
    df['resID_old']=df.resID_old.astype(int)
    df['CS_exp']=df.CS_exp.astype(float)
    df['error_exp']=df.error_exp.astype(float)
    
    #creates the column id_seq, i.e. a sequential numbering of the residues
    df=renumber_sequentially(df,'resID_old','residue')
    sequence=extract_sequence(df.loc[:,['resID_old','residue']]) 
    return df,sequence
    


#def get_starts(index): 
#    '''This function takes an index object with the structure |idx|resID|residue| and returns an index object whose entries are the start of each residue. 
#    The names of the columns of the input index object does not matter. Important is only the order of the columns'''
#    #get columns names: 
#    col1=index.columns[0]
#    col2=index.columns[1]
#    
#    #retrieve starting resID and residue number 
#    resID_pre=index.iloc[0][col1]
#    residue_pre=index.iloc[1][col2]
#    
#    #creates empty index object/dataframe
#    df=pd.DataFrame([[resID_pre,residue_pre]],columns=[col1,col2])
#    
#    
#    for i, row in index.iterrows():
#         if row[col1]!=resID_pre:
#             print(row)
#             print('x')
#             df=df.append(row,ignore_index=False)
#             resID_pre=row[col1]
#    return df



def predicted_df(filename):
    '''predicted_df returns a dataframe with the predictions from ppm contained in the file 'filename' AND
    a the 1-letter sequence of the sequence or residues in the form: dataframe, seq'''
    
    path=os.path.abspath(filename)
    
    #processes output bmrb file from pp by trimming unncessary lines
    process_bmrb(path,'bmrb_pre_pro.dat') 

    #creates pandas dataframe and trims unnessary columns
    data=pd.read_csv('bmrb_pre_pro.dat', delim_whitespace=True,header=None)
    
    
    df=data.loc[:, [1,2,4,5]]    
    df.columns = ['resID_old','residue','atomtype','CS']
    df=renumber_sequentially(df,'resID_old','residue')
    sequence=extract_sequence(df.loc[:,['resID_old','residue']]) 

    return df,sequence



def predicted_ch3(filename):
    '''predicted_ch3 returns a dataframe with the predictions of ch3shift.'''
    #open the file
    path=os.path.abspath(filename)
    try:
        file=open(path, 'r')
    except FileNotFoundError as err: 
        print('The file with ch3shift that you have given does not exist') 

    #read lines
    lines=file.readlines()
    trimmed_lines=[] #list with the new modified lines
    
    
    #trimming the lines
    for line in lines:
        if re.search('\ANOTE',line)==None:
            newLine=line.replace('RESULT: ;','')
            newLine=newLine.rstrip()
            newLine=re.split(r'\s+;\s+',newLine)
            for i in range(len(newLine)):
                element=newLine[i]
                newLine[i]=element.lstrip()    
            trimmed_lines.append(newLine)
    df=pd.DataFrame(trimmed_lines) #pd dataframe from new lines
    df=df.loc[:, [0,1,2,4,5,6,7]] #trimmig unnecesary information

    df.columns=['residue','idPDB','chain','atomtype','CS','err1','err2'] #labeling 
    
    #changing data types and some changes when necessary.
    df.idPDB=df.idPDB.astype(int)
    df.CS[df.CS=='xxxxx']=np.nan
    df.CS=df.CS.astype(float)
    df.err1=df.err1.astype(float)
    df.err2=df.err2.astype(float)
    df.loc[df.chain=='UN', 'chain']= 'A'
    
    return df
    


def no_match_index(alignment):
    '''This function takes an alignment object and return the indices where there is
    discrepancy'''
    no_matches = []
    for i, (a, b) in enumerate(zip(alignment[0], alignment[1])):
        if a != b:
            no_matches.append(i)
    return no_matches



def match_index(alignment):
    '''This function takes an alignment object and return the indices where there is NO
    discrepancy'''
    matches = []
    for i, (a, b) in enumerate(zip(alignment[0], alignment[1])):
        if a == b:
            matches.append(i)
    return matches



def alignment(seq1,seq2,return_matches=False):
    '''alignment returns the consensus string of two sequences. On request (return_matches=True), it can also return
    the indices in the original list of residues that the residues in the consensus correspond to.'''
    
 
    alignments = pairwise2.align.globalxx(seq1,seq2)
    
    #Determine the positions of the differences
    m=no_match_index(alignments[0])
    
    #Retrieve the common sequence 'consensus'
    consensus=''
    resume=0
    for i in range(len(m)):
        consensus = consensus + alignments[0][0][resume:m[i]]
        resume=m[i]+1
    consensus=consensus + alignments[0][0][resume:]
    
    #What indices in my primitive predicted sequences does the consensus residues correspond to?
    alignment_seq2_original_align=pairwise2.align.globalxx(seq2,consensus)
    matches_seq2=match_index(alignment_seq2_original_align[0])
    
    #What indices in my primitive experimental sequences does the consensus residues correspond to?
    alignment_seq1_original_align=pairwise2.align.globalxx(seq1,consensus)
    matches_seq1= match_index(alignment_seq1_original_align[0])
    
   # assert(type(return_matches)==bool,'return_matches must be True or False')
    if return_matches==True:
        return consensus,matches_seq1,matches_seq2
    else:  
        return consensus
    
    
    
def check_nomenclature(reference,versionPDB='PDBV3'):
    '''check_nomenclature asserts that the nomenclature for the atom types used in your reference pdb matches
    the one in the nomenclature.txt file utilized thoughout the program for atom type conversion. 
    In case of mismatches the name of the atom and the residue will be promted for the user to change the 
    corresponding entry manually in the nomenculate.txt file''' 'ADD RETURN MISMATCHES'''
    
    table=pd.read_csv('nomenclature.txt',delim_whitespace=True) #load conversion table
    residues_checked=[] #in oder not to check residues twice
    for idx,row in reference.iterrows():
        if row['residue_name'] not in residues_checked: #check if that residue has already been inspected. 
            atoms_list=reference[(reference.residue_name==row['residue_name']) & (reference.residue_number==row['residue_number'])]['atom_name'].tolist()
            for atom in atoms_list: 
                if atom not in table[table.residue==row['residue_name']][versionPDB].to_list():
                    print('The atom {} from residue {} is not part of the nomenclature you have given. Please, change the nomenclature file accordingly or choose another PDBversion.'.format(atom,row['residue_name']))
            residues_checked.append(row['residue_name'])
        
        

def bmrb_to_pdb(residue,atomtype,versionPDB='PDBV3'):
    
    '''bmbr_to_pdb takes the atomtype of residue in NMR-star nomenclature and translates
    it into pdb nomenculature. The user should check the version of the PDB''' 
    
    table=pd.read_csv('nomenclature.txt',delim_whitespace=True)
    try:
        atomInPDB=table[(table.residue==residue) & (table.BMRB==atomtype)][versionPDB]
    except:
        print('BMRB atomtype not found in the nomenclature directory')

    return atomInPDB.to_list()[0]



def pdb_to_bmrb(residue,atomtype,versionPDB=3):
    
    '''bmbr_to_pdb takes the atomtype of residue in NMR-star nomenclature and translates
    it into pdb nomenculature. The user should check the version of the PDB''' 
    
    table=pd.read_csv('nomenclature.txt',delim_whitespace=True)
    if versionPDB==3:
        try:
            atomInBMRB=table[(table.residue==residue) & (table.PDBV3==atomtype)]['BMRB']
        except:
            print('PDB atomtype not found in the nomenclature directory')
    elif versionPDB==2:
        try:
            atomInBMRB=table[(table.residue==residue) & (table.PDBV2==atomtype)]['BMRB']
        except:
            print('PDB atomtype not found in the nomenclature directory')
    print('The atomtype {} from residue {}  was changed to {}.'.format(atomtype,residue,atomInBMRB))
    return atomInBMRB.to_list()[0]
        


def renumbering_to_reference(reference,df):
    '''This function takes a reference PDB and a pandas Dataframe (experimental o predicted)
    and will create a new column names 'ResID_ref' that will assign each residue in the dataframe 
    the resID of the same residue in the reference pdf. This makes atoms/residue referencing easier across the code since
    ppm output and nmrstar file do not necessarily have the same residue numbering as our reference pdb. If not all
    residues are present in the pdb, the value of ResID_ref for that residue will be nan.
    Returns the modifed dataframe'''
    
    try:
        referencepdb=PandasPdb().read_pdb(reference)
        reference_df=referencepdb.df['ATOM']
        reference_df=renumber_sequentially(reference_df,'residue_number','residue_name')

    except FileNotFoundError as err:
        print(err, '\n', 'The path of the reference PDB is not right. Please, check again. ')
        
    #Extracts the sequences of the reference and the dataframe
    seq_ref=''.join(referencepdb.amino3to1()['residue_name']) #sequency reference pdb 
    seq_df=extract_sequence(df)
#    print(seq_ref,seq_df)

    #get consensus string of df and reference pdb 
    consensus,matches_df,matches_ref=alignment(seq_df,seq_ref,return_matches=True)
#    print('The consensus sequence is ',consensus)
#    print(matches_df,matches_ref)

    #renumbers
    for i in range(len(consensus)):
        id_ref=matches_ref[i]
        id_df=matches_df[i]
        idPDB=int(list(reference_df[reference_df.id_seq==matches_ref[i]]['residue_number'])[0])
        df.at[df.id_seq==matches_df[i],'idPDB']=int(idPDB)
        
    return df
        


def add_error_ppm(index):
    '''This function adds to 'copy' (the compiled_df) the error of the predictor to calculate
    the chi-square later on'''
    copy=index.copy()
    bb_atoms=['C','CB','CA','N','H','HA']
    listError={'C':1.44, 'CA':0.9, 'N':2.31, 'H': 0.43, 'HA':0.24, 'CB':1}
    
    
    error_protons=pd.read_csv('error_protons_ppm.txt',names=['residue','Atomtype','ErrorPPM','Shifts','CH3shift/ArShift','ExperimentalRMSD'])
    error_protons.Atomtype=error_protons.Atomtype.str.replace('*','').tolist()
    for idx,row in copy.iterrows():
        if row['atomtype'] in bb_atoms:
            copy.at[idx,'error_predictor']=listError[row['atomtype']]
        elif re.match(r'H[B-Z]+[1-9]*',row['atomtype'] )!=None:
                if row['atomtype'] not in error_protons[error_protons.residue==row['residue']]['Atomtype'].tolist():
                    error_proton=error_protons[(error_protons.residue==row['residue']) & (error_protons.Atomtype==row['atomtype'][:-1])]['ErrorPPM']
                    
                elif row['atomtype'] in error_protons[error_protons.residue==row['residue']]['Atomtype'].tolist():
                    error_proton=error_protons[(error_protons.residue==row['residue']) & (error_protons.Atomtype==row['atomtype'])]['ErrorPPM']
                
                try:
                    copy.at[idx,'error_predictor']=error_proton
        
                except:
        #                print('No experimental data for this residue')
                    pass

    return copy

def eliminate_duplicate_hydrogens(index):
    '''This function should correct ... '''
    try:
        print('Eliminating duplicated hydrogens resulting from different nomenclatures ...')
        copy=index.copy()
        deleted=[]
        for idPDB in list(set(copy.idPDB)):
            res=copy[copy.idPDB==idPDB]
            unique_elements, counts_elements = np.unique(res['CS_exp'], return_counts=True)
            for i in range(len(unique_elements)):
                if counts_elements[i]>1:
    #                print(counts_elements[i])
                    #check
                    element=unique_elements[i]
                    atomtype=res[res.CS_exp==element]['atomtype'].to_list()[0] #first of the redundants H
                    atomtype_class=''.join([i for i in atomtype if not i.isdigit()])
    #                print(atomtype_class)
                    origin=res[res.CS_exp==element]['_merge'].to_list()[0] 
    #                print(origin)#origine when merging 
                    for idx,row in res[res._merge!=origin].iterrows(): 
    #                    print('test')
                        if re.match(atomtype_class,row['atomtype']):
    #                        print('this actually happens')
    #                        print(row)
                            if not row['CS_exp']>0: #is nan?
                                sel=res[res.CS_exp==element]
                                copy.at[sel.index,'CS']=row['CS']
                                print('eliminates {},{},{}.'.format(row['residue'],row['atomtype'],row['idPDB']))
                                
                                deleted.append(idx)

    #                            print(' CS_exp of {} in residue {} from {} to {}'.format(row['atomtype'],row['residue'],'nan',unique_elements[i]))
    #                            copy.at[idx,'CS_exp']=unique_elements[i]
        print('Done eliminating duplicated protons..')
        copy=copy.drop(deleted)
        copy=copy.reset_index(drop=True)
    except Exception as err:
        print('Something went trom when eliminating duplicated hydrogens')
        print(err)
                                
    return copy
def test():
    print('x')


def add_experimental_data_to_ch3shift(ch3shift,experimental):
    '''This function complements the database of the predictions of CH3shift 
    with the experimental data'''
    print('Adding experimental data to CH3shift predictions ...')
    ch3shift_copy=ch3shift.copy()
    for idx,row in ch3shift_copy.iterrows():
        
        idPDBue_exp=experimental[experimental.idPDB==row['idPDB']]
        sel=idPDBue_exp.atomtype.str.match(row['atomtype'])
        try:
            CS_exp=idPDBue_exp[sel]['CS_exp'].to_list()[0]
    
#            if not CS_exp >0.0: 
#                print('There is no experimental information for the prediction of the atom {} of the idPDBue {}.'.format(row['atomtype'],row['idPDBue']))
            ch3shift_copy.at[idx,'CS_exp']=CS_exp
        except IndexError:
            print('There is no experimental information for the prediction of the atom {} of the residue {} with number {}.'.format(row['atomtype'],row['residue'],row['idPDB']))
    print('Done with the addition of experimental data to CH3shift predictions.')
    return ch3shift_copy
                            
    

def mapping_to_pdb(reference,index,versionPDB='PDBV3',ch3shift_data=None,onlyBB=False): 
    '''This function maps the chiSq of ppm and ch3shift onto the dataframe reference of the PDB'''
    print('Mapping onto PDB ...')
    table=pd.read_csv('nomenclature.txt',delim_whitespace=True)
    atomtype_bb=['C','CB','CA','N','H','HA']

    counter=0
    reference_copy=reference.copy()
    reference_copy['b_factor']=0
    if ch3shift_data==None:
        for idx,row in index.iterrows():
            if not np.isnan(row['ChiSq']):
                try:
                    atomInPDB=table[(table.BMRB==row['atomtype']) & (table.residue==row['residue'])][versionPDB].to_list()[0]
                    print('Atom name in BMRB file {} mapped to {} on your PDB'.format(row['atomtype'],atomInPDB))
                    sel=reference_copy[(reference_copy.residue_number==row['idPDB']) & (reference_copy.residue_name==row['residue']) & (reference_copy.atom_name==atomInPDB)]
                    reference_copy.at[sel.index,'b_factor']=row['ChiSq']
                except:
                    print('I could not find in the PDB the atom {} of residue {} when mapping the ChiSq'.format(row['atomtype'],row['idPDB']))
    else:
        for idx,row in index.iterrows():
            if not np.isnan(row['ChiSq']):
                try:
                    atomInPDB=table[(table.ch3shift==row['atomtype']) & (table.residue==row['residue'])][versionPDB].to_list()[0]
                    sel=reference_copy[(reference_copy.residue_number==row['idPDB']) & (reference_copy.residue_name==row['residue']) & (reference_copy.atom_name==atomInPDB)]
                    reference_copy.at[sel.index,'b_factor']=row['ChiSq']

                except:
                    print('I could not find in the PDB the atom {} of residue {} when mapping the ChiSq'.format(row['atomtype'],row['residue']))
    print('Done with PDB mapping')
    return reference_copy


def mapping_BB_chi_per_residue(reference,index):
    '''This function calculates the average of the BB chi-squares per residue, and sets the b-factor of all the atoms in the residue to that average value. Residues with no chi-squares are set their b-factors to -1 so we can distinguish properly "no information" from "low chi-squared".'''
    reference_copy=reference.copy()
    reference_copy['b_factor']=-1
    atomtype_bb=['C','CB','CA','N','H','HA']
    list_of_residue_numbers=list(set(index['idPDB']))

    for resid in list_of_residue_numbers:
        residue=index.loc[(index['idPDB']==resid )& (index['atomtype'].isin(atomtype_bb))  &  (index['ChiSq']>0)]
        mean=residue['ChiSq'].mean()
        sel=reference_copy[reference_copy.residue_number==resid]
        reference_copy.at[sel.index,'b_factor']=mean
    reference_copy.at[reference_copy['b_factor'].apply(np.isnan),'b_factor']=-1
    return reference_copy
   
    
######## OUTPUT FUNCTIONS #############################################
def output_RMSE_ppm_BB(dataframe):
    atomtype_bb=['C','CB','CA','N','H','HA']

    print('Preparing output for RMSE for H,HA,C,CB,CA and N')
    df_RMSE_BB=pd.DataFrame(columns=['Atom Type','RMSE','Entries used'])
    orig_stdout = sys.stdout
    f = open('output_RMSE_ppm_BB.txt', 'w')
    sys.stdout = f
    counts_per_atom_type={}
    for atomtype in atomtype_bb:
        #retrieve values for one atomtype
        atoms=dataframe[(dataframe.atomtype==atomtype) & (dataframe.error_squared>0)]
        try: 
            counts_per_atom_type.update({'{}'.format(atomtype): len(atoms)})
            RMSE=(sum(atoms.error_squared.to_list())/len(atoms))**0.5
            ne=pd.DataFrame([[atomtype,RMSE,len(atoms)]],columns=['Atom Type','RMSE','Entries used'])
            df_RMSE_BB=df_RMSE_BB.append(ne,ignore_index=True)
        except ZeroDivisionError:
            print('For the backbone RMSE predictions, I could not find  predictions for the atomtype {}. Maybe your experimental data contained no entries for it.'.format(atomtype))
    #    ChiSq_red=
        
    print(df_RMSE_BB)
    sys.stdout = orig_stdout
    f.close()
    pd.DataFrame.to_csv(df_RMSE_BB,path_or_buf='output_RMSE_ppm_BB.csv',index=False)
    print('Done')



def output_chi_squared_BB(dataframe):
    atomtype_bb = ['C','CB','CA','N','H','HA']
    print('Preparing output for ChiSq for H,HA,C,CB,CA and N ...')

    orig_stdout = sys.stdout
    df_chi_BB = pd.DataFrame(columns=['Atom Type','Chi-2 reduced','STD', 'Entries used'])
    
    f = open('output_chi_squared_BB.txt', 'w')
    sys.stdout = f
    
    counts_per_atom_type={}
    for atomtype in atomtype_bb:

        #retrieve values for one atomtype
        atoms = dataframe[ (dataframe.atomtype==atomtype) & (dataframe.ChiSq>0) ]
        
        try:
            counts_per_atom_type.update({'{}'.format(atomtype): len(atoms)})
            ChiSq_red = atoms['ChiSq'].mean()
            std_ChiSq_red = atoms['ChiSq'].std()
            ne = pd.DataFrame([ [atomtype, ChiSq_red, std_ChiSq_red, len(atoms)] ], columns = ['Atom Type','Chi-2 reduced', 'STD', 'Entries used'])
            df_chi_BB = df_chi_BB.append(ne, ignore_index=True)
        
        except ZeroDivisionError:
            print('For the backbone reduced Chi-square predictions, I could not find predictions for the atom type {}. Maybe experimental data contained no entries for it.'.format(atomtype))
    
    print(df_chi_BB)
    sys.stdout = orig_stdout
    f.close()
    pd.DataFrame.to_csv(df_chi_BB,path_or_buf='output_chi_squared_BB.csv',index=False)    
    print('Done')


def output_chi_squared_C_ch3shift(dataframe):
    print('Preparing output for Cs of CH3shift.')
    orig_stdout = sys.stdout
    df_chi_c=pd.DataFrame(columns=['residue','Atom Type','Chi-2 reduced','Entries used'])
    f = open('output_chi_squared_C_ch3shift.txt', 'w')
    sys.stdout = f
    carbons_ch3={'LEU':['CD1','CD2'],'ILE':['CG2','CD'],'VAL':['CG1','CG2'],'THR':['CG2']}
    #### Compute chi-2 metrics ###  
    #print('{} ;  {} ;  {} ;   {}'.format('residue','Atom type', 'Chi-Sq reduced','# entries used'))
    
    for key in carbons_ch3.keys():
        for at in carbons_ch3[key]:
            
            ## selects all the atoms of a residue type (e.g.: LEU) and of a certain atomtype (e.g.:CD2).
            ## So the idea is that at the end of the iteration, we have an average chi-sq for e.g. all CD2s of all LEUs. 
            sel_atomtype=ch3shift[(ch3shift.residue==key)&(ch3shift.atomtype==at)&(ch3shift.ChiSq>0.00)]
            if len(sel_atomtype)>0:
                chiSq_red=sum(sel_atomtype['ChiSq'])/len(sel_atomtype['ChiSq'])
                ne=pd.DataFrame([[key,at,chiSq_red,len(sel_atomtype)]],columns=['residue','Atom Type','Chi-2 reduced','Entries used'])
                df_chi_c=df_chi_c.append(ne,ignore_index=True)
    #            print('Chi-2 reduced for {} of {} is: {}'.format(at,key,chiSq_red))
    #            print('{}  ;  {}  ;  {}   ;  {}'.format(key,at,chiSq_red,len(sel_atomtype)))
            else:
    #            print('{}  ;   {}   ;   {}   ;   {}'.format(key,at,np.nan,np.nan))  
                ne=pd.DataFrame([[key,at,np.nan,np.nan]],columns=['residue','Atom Type','Chi-2 reduced','Entries used'])
                df_chi_c=df_chi_c.append(ne,ignore_index=True)
                
    print('# np.nan means that atom is not in structure or no experimental information has been made available')
    print(df_chi_c)
    sys.stdout = orig_stdout
    f.close()
    pd.DataFrame.to_csv(df_chi_c,path_or_buf='output_chi_squared_C_ch3shift.csv',index=False)   
    print('Done')



def output_chi_squared_H_ppm(dataframe):  
    print('Preparing output for the ChiSq of side-chain hydrogens predictions from PPM ...')
    orig_stdout = sys.stdout

    #obtain list of protons 
    regex=dataframe.atomtype.str.match(r'H[B-Z]+[1-9]*')
    protons=dataframe[(regex) & dataframe.ChiSq>0]
    
    #set with computed atomtypes so far so avoid repetitions
    computed=set()
    
    #data frame for data storage 
    df_chi_Hs=pd.DataFrame(columns=['residue','Atom Type','Chi-2 reduced','Entries used'])
    
    #creates outputfile
    f = open('output_chi_squared_H_ppm.txt', 'w')
    sys.stdout = f
    
    for index,row in protons.iterrows():
        if (row['residue'],row['atomtype']) not in computed:
            computed.add((row['residue'],row['atomtype']))
            sel=protons[(protons.residue==row['residue']) & (protons.atomtype==row['atomtype']) & (protons.ChiSq>0)]
            try: 
                chiSq_red=sum(sel['ChiSq'])/len(sel['ChiSq'])
                ne=pd.DataFrame([[row['residue'],row['atomtype'],chiSq_red,len(sel)]],columns=['residue','Atom Type','Chi-2 reduced','Entries used'])
                df_chi_Hs=df_chi_Hs.append(ne,ignore_index=True)
            except ZeroDivisionError:
                print('No entries for proton type {}.'.format(row['atomtype']))
        else: 
            pass
    print(df_chi_Hs)
    sys.stdout = orig_stdout
    f.close() #closes output file
    
    #creates csv file with results
    pd.DataFrame.to_csv(df_chi_Hs,path_or_buf='output_chi_squared_H_ppm.csv',index=False)
    print('Done')
#    
    
    
    
    

    
###############################################################################
###############              EXECUTION                        ################
###############################################################################
 
    
    

if __name__=='__main__':
    ########################################################################################################################
    ####   DATA BASES 
    ## Choose PDB nomenclature
    pdb_options={3:'PDBV3',2:'PDBV2'}
    versionPDB=pdb_options[args.pdb_nom]
    
    reference=args.reference
    try:
        referencepdb=PandasPdb().read_pdb(reference)
        reference_df=referencepdb.df['ATOM']
        reference_df=renumber_sequentially(reference_df,'residue_number','residue_name')

    except FileNotFoundError as err:
        print(err, '\n', 'The path of the reference PDB is not right. Please, check again. ')
        sys.exit('Execution aborted due to missing reference PDB')
        
    #check nomenclature 
    check_nomenclature(reference_df,versionPDB=versionPDB)
        
    #Creates pandas data frame for experimental and predictions. 
    experimental,seq_exp=experimental_df(args.experimental) #args.experimental
    predicted,seq_pre=predicted_df(args.bmrb_pre) #args.bmrb_pre
    
    #renumbers according to PDB numbering. New numbering goes into column idPDB
    experimental=renumbering_to_reference(args.reference,experimental)
    predicted=renumbering_to_reference(args.reference,predicted)


    #addition of experimental data to 
    left=predicted
    right=experimental.loc[:,['idPDB','residue','atomtype','CS_exp','error_exp','id_seq']]
    
    
    #df_compiled contains the merged data of experimental and predicted
    df_merged=pd.merge(left, right, how='outer', on=['idPDB','residue','atomtype'], left_on=None, right_on=None,
         left_index=True, right_index=False, sort=True,
         suffixes=('_x', '_y'), copy=True, indicator=True,
         validate=None)
    df_merged.index=range(len(df_merged))
    df_merged=df_merged[df_merged.idPDB>0].loc[:,['idPDB','residue','atomtype','CS','CS_exp','error_exp','_merge']]
    
    #add_error of PPM 
    df_merged=add_error_ppm(df_merged)
    
    
    #deal with equivalent hydrogens. E.g. HE1, HE2, HE3 appearing as HE in experimental
    #but as HE1,HE2,HE3 in predicted. This would lead to having HE,HE1,HE2,HE3 
    #in the compiled merged dataframe. We fix it here. 
    df_merged=eliminate_duplicate_hydrogens(df_merged)
    
    #Error squared and ChiSq
    df_merged['error_squared']=(df_merged['CS']-df_merged['CS_exp'])**2
    df_merged['ChiSq']=df_merged['error_squared']/df_merged['error_predictor']**2
    
    
    
    if bool(args.ch3_shift):

        ch3shift=predicted_ch3(args.ch3_shift)
        
        #We discard MET predictions
        ch3shift=ch3shift[ch3shift.residue!='MET']
        
        
        #add experimental data
        ch3shift=add_experimental_data_to_ch3shift(ch3shift,experimental)
        
        #Error squared and ChiSq
        ch3shift['error_squared']=(ch3shift['CS']-ch3shift['CS_exp'])**2
        ch3shift['ChiSq']=ch3shift['error_squared']/ch3shift['err2']**2
    
    ### Generating output
    print('Generating output in ',os.getcwd())
    output_RMSE_ppm_BB(df_merged)
    output_chi_squared_BB(df_merged)
    output_chi_squared_H_ppm(df_merged)
    df_merged.to_csv('summary_PPM.csv')

    if bool(args.ch3_shift):

        output_chi_squared_C_ch3shift(ch3shift)
        ch3shift.to_csv('summary_CH3shift.csv')
    
    #mapping PPM chi squared
    newPDB=PandasPdb().read_pdb(args.reference)
    newPDB.df['ATOM']=mapping_to_pdb(newPDB.df['ATOM'],df_merged,versionPDB=versionPDB)
    newPDB.to_pdb(path='reference_chi_squared_ppm.pdb')
   
    #mapping PPM BB-average chi-squared per residue. 
    PDB_BB_average_per_residue=PandasPdb().read_pdb(args.reference)
    PDB_BB_average_per_residue.df['ATOM']= mapping_BB_chi_per_residue(PDB_BB_average_per_residue.df['ATOM'],df_merged)
    PDB_BB_average_per_residue.to_pdb(path='reference_BB_chi_squared_averaged_residue_ppm.pdb')
    
    if bool(args.ch3_shift):

        #mappinig ch3shift chi squared
        newPDB=PandasPdb().read_pdb(args.reference)
        newPDB.df['ATOM']=mapping_to_pdb(newPDB.df['ATOM'],ch3shift,versionPDB=versionPDB,ch3shift_data=True)
        newPDB.to_pdb(path='reference_chi_squared_ch3shift.pdb')
        

##################################################################################################3
        
#    
